
go 和 c++ 区别

GO                              C++ 
面向过程和并发的语言             面向对象
无构造函数析构函数               有构造函数析构函数
自动垃圾回收                     无自动垃圾回收
包含文件使用包名                  包含文件的头文件
go携程                           支持多线程
不支持继承                        支持继承
不支持函数重载                   支持函数重载


什么是死锁
a转账给b   的过程
线程1锁住a  正在获取b 
线程2锁着b  正在获取a  
2个线程都在获取对方锁着的资源  导致死锁

避免死锁的方式：
  1：不使用互斥锁，使用原子操作
  2：设置锁的超时时间
  3：线程1将要用到的资源一开始同时锁主
  4：锁资源的时候 采用同样的顺序锁主
  
 redis 雪崩 击穿 穿透
 
 一些冷门的数据一开始不存在redis ，如果大量需求，=或者过期了，在redis中没有 ，那么大量的请求就会到数据库中
 如何避免：1：对请求redis 的接加锁  ，同时只能一个请求查询
 redis 挂了，或者大规模的key 过期失效了：
           2： 设置随机的线性的过期时间
redis 如果挂了 ：1： 设置redis 集群

缓存击穿：  就是大量的请求 id  在redis 和MySQL 都没有 的额可以攻击
  解决方法： 
            1：使用布隆过滤器  将存在的id都放上面，对请求的id过滤
            
            
panic ：触发 三种方式：  
主动方式：
1：程序猿主动调用 panic( ) 函数；

被动的方式：
2：编译器的隐藏代码触发：      a/0  编译器偷偷加上了一段 if/else 的判断逻辑，并且还给加了 runtime.panicdivide  的代码。
3：内核发送给进程信号触发 ：   在 Go 进程启动的时候会注册默认的信号处理程序（ sigtramp ）
                               在 cpu 访问到 0 地址会触发 page fault 异常，这是一个非法地址，内核会发送 SIGSEGV 信号给进程，所以当收到 SIGSEGV 信号的时候，就会让 sigtramp 函数来处理，最终调用到 panic 函数 

  
            
