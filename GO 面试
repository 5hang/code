
go 和 c++ 区别

GO                              C++ 
面向过程和并发的语言             面向对象
无构造函数析构函数               有构造函数析构函数
自动垃圾回收                     无自动垃圾回收
包含文件使用包名                  包含文件的头文件
go携程                           支持多线程
不支持继承                        支持继承
不支持函数重载                   支持函数重载


什么是死锁
a转账给b   的过程
线程1锁住a  正在获取b 
线程2锁着b  正在获取a  
2个线程都在获取对方锁着的资源  导致死锁

避免死锁的方式：
  1：不使用互斥锁，使用原子操作
  2：设置锁的超时时间
  3：线程1将要用到的资源一开始同时锁主
  4：锁资源的时候 采用同样的顺序锁主
  
 redis 雪崩 击穿 穿透
 
 一些冷门的数据一开始不存在redis ，如果大量需求，=或者过期了，在redis中没有 ，那么大量的请求就会到数据库中
 如何避免：1：对请求redis 的接加锁  ，同时只能一个请求查询
 redis 挂了，或者大规模的key 过期失效了：
           2： 设置随机的线性的过期时间
redis 如果挂了 ：1： 设置redis 集群

缓存击穿：  就是大量的请求 id  在redis 和MySQL 都没有 的额可以攻击
  解决方法： 
            1：使用布隆过滤器  将存在的id都放上面，对请求的id过滤
            
            
panic ：触发 三种方式：  
主动方式：
1：程序猿主动调用 panic( ) 函数；

被动的方式：
2：编译器的隐藏代码触发：      a/0  编译器偷偷加上了一段 if/else 的判断逻辑，并且还给加了 runtime.panicdivide  的代码。
3：内核发送给进程信号触发 ：   在 Go 进程启动的时候会注册默认的信号处理程序（ sigtramp ）
                               在 cpu 访问到 0 地址会触发 page fault 异常，这是一个非法地址，内核会发送 SIGSEGV 信号给进程，所以当收到 SIGSEGV 信号的时候，就会让 sigtramp 函数来处理，最终调用到 panic 函数 

  
 go 内存逃逸：
  1：如果函数外部没有引用，优先放在栈上
  2：如果函数外部存在引用，优先放在堆上
  3：如果栈放不下，放在堆上面
  
  发生逃逸的集中情况：
  1：只想栈的指针的逃逸
  2：栈空间不够了
  3：动态类型
  4：闭包引用类型
  
  总结：栈分配内存比堆上面效率高
        栈分配的内存不用GC处理
        逃逸分析在编译期间完成的


mysql 优缺点：
优点：

体积小、速度快、总体拥有成本低，开源、支持多种操作系统。
是开源数据库，提供的接口支持多种语言连接操作。
MySql的核心程序采用完全的多线程编程。线程是轻量级的进程，它可以灵活地为用户提供服务，而不过多的系统资源。用多线程和C语言实现的MySql能很容易充分利用CPU。
MySql有一个非常灵活而且安全的权限和口令系统。当客户与MySql服务器连接时，他们之间所有的口令传送被加密，而且MySql支持主机认证。
支持ODBC for Windows， 支持所有的ODBC 2.5函数和其他许多函数， 可以用Access连接MySql服务器， 使得应用被扩展。
支持大型的数据库， 可以方便地支持上千万条记录的数据库。作为一个开放源代码的数据库，可以针对不同的应用进行相应的修改。
拥有一个非常快速而且稳定的基于线程的内存分配系统，可以持续使用面不必担心其稳定性。
MySQL同时提供高度多样性，能够提供很多不同的使用者介面，包括命令行客户端操作，网页浏览器，以及各式各样的程序语言介面，例如C+，Perl，Java，PHP，以及Python。你可以使用事先包装好的客户端，或者干脆自己写一个合适的应用程序。MySQL可用于Unix，Windows，以及OS/2等平台，因此它可以用在个人电脑或者是服务器上。
缺点：

不支持热备份。
MySQL***的缺点是其安全系统，主要是复杂而非标准，另外只有到调用mysqladmin来重读用户权限时才发生改变。
没有一种存储过程(Stored Procedure)语言，这是对习惯于企业级数据库的程序员的***限制。
MySQL的价格随平台和安装方式变化。Linux的MySQL如果由用户自己或系统管理员而不是第三方安装则是免费的，第三方案则必须付许可费。Unix或Linux 自行安装 免费 、Unix或Linux 第三方安装收费。
  
  
  
 Go  Channel 特性
// 未初始化的channel 收发数据 panic错误
// 仅一个协程无缓冲 读写 没有了另一个协程写读，报错 死锁
// 关闭的channel 写入    panic错误
// 关闭已经关闭的channel panic错误
// 关闭未初始化的channel panic错误
// 关闭的channel 读取 返回 0 false

会阻塞的情况：
1. 从未初始化nil channel中读数据
2. 向未初始化nil channel中发数据
3.在没有读取的groutine时，向无缓冲channel发数据
4.在没有数据时，从无缓冲channel读数据
返回零值:
从已经关闭的channe接收数据

Go routine 退出阿方式
goroutine 终止的场景有三个：
当一个 goroutine 完成了它的工作
由于发生了没有处理的错误
有其他的协程告诉它终止

什么时候会导致死锁
在计算机组成原理里说过 死锁有三个必要条件他们分别是 循环等待、资源共享、非抢占式，在并发中出现通道死锁只有两种情况：
数据要发送，但是没有人接收
数据要接收，但是没有人发送




程序在内存上被分为堆区、栈区、全局数据区、代码段、数据区五个部分


内存回收的方法
1：引用基数算法：     容易简答    但是无法解决循环引用的问题
2：可达性分析算法：

go gc 设计算法：三色标记算法： 标记清除算法 ，从根节点开始便利所有对象，标记引用的对象，，没有被标记的进行回收了
缺点：需要暂停程序；  go 1.5后 采用三色标记发 和 混合写屏障算法。 gc 过程其和他的goroutine 并行的 ，但是需要一定的stw时间。


启动swt  ===》 mark标记 ===》清除垃圾 ====》停止swt
启动swt  ===》 mark标记 ===》 停止swt====》清理垃圾

gc的过程：
标记开始 先暂停程序
从根节点开始遍历标记
清除没有被标记的节点
程序重新开始




 
https://learnku.com/articles/59021
GO  1.3 标记清除算法             缺点遍历整个堆  stop the word
GO  1.5 三色标记发：            开启stw  可以  ，不开启stw 会误删有用的数据（引入了插入屏障和删除屏障）
Go1.8 三色标记 + 混合写屏障     gc耗时低于1毫秒的

基于插入写屏障和删除写屏障在结束时需要 STW 来重新扫描栈，所带来的性能瓶颈，Go 在 1.8 引入了混合写屏障的方式实现了弱三色不变式的设计方式，混合写屏障分下面四步

GC 开始时将栈上可达对象全部标记为黑色（不需要二次扫描，无需 STW）

GC 期间，任何栈上创建的新对象均为黑色

被删除引用的对象标记为灰色

被添加引用的对象标记为灰色
 






go gc 触发的时机： 1：分配的内存达到了gogc的比例 2：后台触发 go自己检测 3：手动触发  runtime.GC 
触发 GC 有俩个条件，一是堆内存的分配达到控制器计算的触发堆大小，初始大小环境变量 GOGC，之后堆内存达到上一次垃圾收集的 2 倍时才会触发 GC。二是如果一定时间内没有触发，就会触发新的循环，该触发条件由
 


GMP模型的理解
https://www.sohu.com/a/457981360_355140

https://learnku.com/articles/41728

服务发现的种类：
基于Raft算法的Consul机制
基于Http协议的分布式Etcd机制
重量级一致性Zookeeper机制

