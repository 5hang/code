

事务的隔离级别 （隔离级别越高 数据越安全，性能越低奥）
事务的四个特性  ：原子性 一致性 持久性  隔离性

隔离级别    脏读    不可重复读     幻读         （这些问题是有事务的并发而引起的奥）
读未提交    未解决   未解决        未解决
读已提交    解决     未解决        未解决
重复度      解决      解决         未解决        mysql默认
串行        解决      解决         解决         项目用这个


查看隔离级别
select @@transaction_isolation;

设置数据库的事务隔离级别
set session TRANSACTION isolation level read UNCOMMITTED;


mysql 引擎  5.5后默认innodb；
创建的每个表  可以指定使用的存储引擎的；
create table xx(
...
)engine=innodb;  


查询数据库支持的所有的引擎
show engines;


innodb 特点： 支持事务、行级锁表级锁，支持外键约束
每个innodb的表 都有一个表空间过的文件 .idb ，存储了 表结构，表的数据  存储的索引

myisam：不支持事务，支持表锁  访问速度快

存储引擎的选择： 
innodb：对并发，数据完整性要求高的，有增删改查的 
myisam： 以读  插入位置，比如 日志  （mongodb 替代它）
memory： 数据村在内存中的           （redis 替代他）

索引是在存储引擎实现的，不同的引擎，索引的实现方式不同的




*****************************************索引：帮助mysql高效获取数据的数据结构

没有索引：需要扫描整张表 ，效率极低的
索引：就是创建一个二叉树，这个二叉树的每个节点，指向表中的每一行

索引优点：提高查询 排序的效率
缺点：    索引要存在磁盘，浪费空间，  降低更新表的操作，需要实时维护索引的

b 树： 平衡二叉树： 
例如5阶b树：   每个节点的元素不能超过5个，插入元素 超过对于的个数的时候，中间元素向上分裂；

b+ 树： 所有的数据存放在叶子节点，叶子节点 单项链表了b+树 ，在b树分裂的基础上，分裂的元素 ，在向上分裂的过程中，还会出现在叶子节点中，
        同时  叶子节点 呈现从左到右的 单项链表

mysql的b+树；在标准的b+树的基础上， 叶子节点 增加双向指向的  链表



索引的分类：
主键索引： 默认索引，只有一个的
唯一索引： 可多个
常规索引： 可多个
全文索引：


聚集索引： 只能有一个默认主键就是：  索引的叶子节点保存行的数据
二级索引： 其他的索引：叶子节点保存id数据

select * from where name = "zhangsan" 查询过程是先拿name在二级索引的b+树查找到 id
再拿这个id 到 主键索引中查到一行的值


、、创建索引
         不填写 表示常规索引
create [unique | FULLTEXT ] index index_name on table_name (colname,...);

查看索引：
show index from table_name;
删除索引：
drop index index_name on table_name;


sql 性能分析：主要是sql的查询的优化：
优先确定当前数据库 主要是哪些操作
show global status like 'Com_______'

Com_binlog    0
Com_commit    0
Com_delete    0
Com_insert    0
Com_repair    0
Com_revoke    0
Com_select    100
Com_signal    0
Com_update    0
Com_xa_end    0


通过mysq 的慢查询日志 找到哪些sql 需要优化的；
show variables like 'slow_query_log';   默认没有打开的
slow_query_log	OFF

修改/etc/my.cnf 开启慢查询
#开启慢查询日志开关
slow_query_log=1
#设置慢查询时间，如果超过了2s ，则记录查询的日志
long_query_time=2;

重启mysql 开启了慢查询后  ，满足条件的慢查询 会存放再 /var/lib/mysql/xxx-slow.log 文件中的奥
有了这个文件就可以分析 MySQL的 语法哪些是需要优化的了


有时候慢查询统计 sql 快慢还不够 ，需要profile分析功能的
select @@have_profiling;   查看是否支持
select @@profiling;         查看是否打开


show PROFILES;  来查询当前会话所有的操作的耗时了

show profiles for query query_ID; 对上面操作的id 每一步进行分析，到底哪个操作慢



上面的方式做sql 优化是按照时间来统计的 并不能做到最好
下面  explain 执行计划： 来统计每一天sql的操作的每一步 看看是如何执行的
 
 explan + sql 语法；




mysql 锁：

全局锁： 锁整个数据库的所有的表 ，加锁后只能读取了 （一般用于数据库的全局备份了）

表锁：

行锁：











